% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/append_labels.R
\name{append_labels}
\alias{append_labels}
\title{Append labels to a dataframe containing question codes}
\usage{
append_labels(
  df,
  colname = "name",
  source = enlabel_cache$codes_and_labels,
  trim = FALSE
)
}
\arguments{
\item{df}{A dataframe to be labelled.}

\item{colname}{Name of the column with LimeSurvey question codes.}

\item{source}{A dataframe containing question labels.}

\item{trim}{If \code{TRUE}, \code{append_labels()} will attempt to include only the subquestion text
and discard the parent-question text.}
}
\description{
One of the most common operations when working with multiplechoice survey
data spread across a number of columns involves transforming the data
from wide to long format. Long format data, especially in the tidyverse context,
lends itself more easily to certain kinds of analyses and visualisations. However,
the output of these transformations usually comprises (only)
numbers and question codes and can be difficult to read, interpret, and communicate.
append_labels() aims to solve this problem by adding a new column to your data
with human-readable labels.

For the function to work, the names of the variables in your dataframe
\emph{have to match the question codes in your LimeSurvey survey}.
}
\details{
Appends a column of human-readable labels to a dataframe containing. The labels have
to be first sourced using \code{extract_labels_from_ls} or \code{extract_labels_from_data}.
}
\section{Example}{


The example below presents a typical tasks when working with
survey data - selecting and summarising a group of variables sharing a
common prefix. The names of the pivoted variables (i.e. question codes) are
stored in the "name" column.

Adding \code{append_labels()} after a pipe at the end of the code block, appends human-readable
labels to question codes present in your data. By default, \code{append_labels()}
searches for the codes in the "name" column. It is designed to to fit into
the dplyr select-and-pivot pipeline without the need to specify any additional arguments.
\emph{The labels have to be sourced} first with the \code{extract_labels_from_ls} or \code{extract_labels_from_data} functions.*\preformatted{
example_data \%>\%
    select(starts_with('example_prefix')) \%>\%
    pivot_longer(everything()) \%>\%
    count(name, value) \%>\%
    group_by(name) \%>\%
    summarise(proportion = n / sum(n), value = value) \%>\%
    append_labels()

}

When working with multiple surveys, you can assign the extracted labels
to a variable and then use it in a call to \code{append_labels()}.

You can also explicitly define the name of the column containing
question codes.\preformatted{
survey1_labels <- extract_labels_from_data(survey1_number)
survey2_labels <- extract_labels_from_ls(survey2_number)

example_data_from_survey2 \%>\%
    select(starts_with('example_prefix')) \%>\%
    pivot_longer(everything(), names_to = 'new_name') \%>\%
    count(name, value) \%>\%
    append_labels(survey2_labels, 'new_name')

}
}

